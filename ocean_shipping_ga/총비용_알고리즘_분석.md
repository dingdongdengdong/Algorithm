# πΆ ν•΄μƒ μ΄μ†΅ GA μµμ ν™” - μ΄λΉ„μ© μ•κ³ λ¦¬μ¦ λ¶„μ„

## π“‹ κ°μ”

μ΄ λ¬Έμ„λ” ν•΄μƒ μ΄μ†΅ μµμ ν™”λ¥Ό μ„ν• μ μ „ μ•κ³ λ¦¬μ¦(GA)μ—μ„ **μ΄λΉ„μ© κ³„μ‚° μ•κ³ λ¦¬μ¦**μ΄ μ„Έλ€κ°€ μ§€λ‚λ©΄μ„ μ–΄λ–»κ² μ‘λ™ν•λ”μ§€ μƒμ„Έν λ¶„μ„ν•©λ‹λ‹¤.

## π§¬ GA μµμ ν™” κ³Όμ •μ—μ„μ λΉ„μ© κ³„μ‚°

### 1. μ„Έλ€λ³„ λΉ„μ© κ³„μ‚° μ‹μ 

```python
# ga_optimizer.pyμ run() λ©”μ„λ“μ—μ„
if generation % 100 == 0:  # 100μ„Έλ€λ§λ‹¤ μƒμ„Έ λΉ„μ© μ •λ³΄ μ¶λ ¥
    total_cost = self.fitness_calculator.calculate_total_cost(best)
    penalty = self.fitness_calculator.calculate_penalties(best)
    print(f"  β”β”€ μ΄ λΉ„μ©: ${total_cost:,.0f}")
    print(f"  β”β”€ ν¨λ„ν‹°: {penalty:.0f}")
    print(f"  β””β”€ Full/Empty: {np.sum(best['xF']):.0f}/{np.sum(best['xE']):.0f} TEU")
```

**λΉ„μ© κ³„μ‚° λΉλ„:**
- **λ§¤ μ„Έλ€**: μ ν•©λ„ κ³„μ‚° μ‹ λ‚΄λ¶€μ μΌλ΅ λΉ„μ© κ³„μ‚°
- **100μ„Έλ€λ§λ‹¤**: μƒμ„Έ λΉ„μ© μ •λ³΄ μ¶λ ¥
- **κ°μ„  μ‹**: μ¦‰μ‹ λΉ„μ© μ •λ³΄ μ¶λ ¥

### 2. μ΄λΉ„μ© κ³„μ‚° κ³µμ‹

#### π“ κΈ°λ³Έ λΉ„μ© κµ¬μ„±μ”μ†

```python
def calculate_total_cost(self, individual: Dict[str, Any]) -> float:
    """μ΄ λΉ„μ© κ³„μ‚°"""
    total_cost = 0
    
    for idx, i in enumerate(self.params.I):
        # 1. μ΄μ†΅ λΉ„μ© (Full μ»¨ν…μ΄λ„)
        base_cost = self.params.CSHIP + self.params.CBAF
        delay_penalty = self.params.CETA * self.params.DELAY_i.get(i, 0)
        total_cost += (base_cost + delay_penalty) * individual['xF'][idx]
        
        # 2. λΉ μ»¨ν…μ΄λ„ μ΄μ†΅ λΉ„μ©
        total_cost += self.params.CEMPTY_SHIP * individual['xE'][idx]
    
    return total_cost
```

#### π’° λΉ„μ© νλΌλ―Έν„° μƒμ„Έ

| νλΌλ―Έν„° | μ„¤λ… | λ‹¨μ„ | μ„¤μ • μ„μΉ |
|---------|------|------|-----------|
| `CSHIP` | κΈ°λ³Έ μ΄μ†΅λΉ„ | USD/TEU | κ³ μ •κ°’ λ°μ΄ν„° |
| `CBAF` | μ λ¥ν• μ¦λ£ | USD/TEU | κ³ μ •κ°’ λ°μ΄ν„° |
| `CETA` | ETA μ§€μ—° ν¨λ„ν‹° | USD/μΌ | κ³ μ •κ°’ λ°μ΄ν„° |
| `CEMPTY_SHIP` | λΉ μ»¨ν…μ΄λ„ μ΄μ†΅λΉ„ | USD/TEU | `CSHIP + CBAF` |

### 3. μ„Έλ€λ³„ λΉ„μ© λ³€ν™” μ¶”μ 

#### π” λΉ„μ© κ³„μ‚° νλ¦„λ„

```
μ„Έλ€ μ‹μ‘
    β†“
μ ν•©λ„ κ³„μ‚° (calculate_fitness)
    β†“
μ΄λΉ„μ© κ³„μ‚° (calculate_total_cost)
    β†“
ν¨λ„ν‹° κ³„μ‚° (calculate_penalties)
    β†“
μµμΆ… μ ν•©λ„ = -(μ΄λΉ„μ© + ν¨λ„ν‹°)
    β†“
μ„ νƒ μ—°μ‚° (selection)
    β†“
κµμ°¨/λ³€μ΄ μ—°μ‚° (crossover/mutation)
    β†“
μƒ μ„Έλ€ μƒμ„±
    β†“
100μ„Έλ€λ§λ‹¤ λΉ„μ© μ •λ³΄ μ¶λ ¥
```

#### π“ μ„Έλ€λ³„ λΉ„μ© λ¨λ‹ν„°λ§

```python
# μ„Έλ€ ν†µκ³„ μ €μ¥
generation_stat = {
    'generation': generation,
    'best_fitness': best['fitness'],
    'diversity': diversity,
    'mutation_rate': current_mutation_rate,
    'improvement': improvement
}
self.params.generation_stats.append(generation_stat)
```

## π― λΉ„μ© μµμ ν™” μ „λµ

### 1. μ μ‘μ  λμ—°λ³€μ΄μ¨

```python
# λ‹¤μ–‘μ„±μ— λ”°λ¥Έ λ³€μ΄μ¨ μ΅°μ •
current_mutation_rate = self.genetic_operators.adaptive_mutation_rate(generation, diversity)
self.params.p_mutation = current_mutation_rate
```

**μ „λµ:**
- **λ†’μ€ λ‹¤μ–‘μ„±**: λ‚®μ€ λ³€μ΄μ¨λ΅ μ•μ •ν™”
- **λ‚®μ€ λ‹¤μ–‘μ„±**: λ†’μ€ λ³€μ΄μ¨λ΅ νƒμƒ‰ κ°•ν™”

### 2. μλ ΄ κ°μ§€ λ° μ΅°κΈ° μΆ…λ£

```python
# μλ ΄ κ°μ§€
if stagnation_counter >= self.params.convergence_patience:
    print(f"\nβΉοΈ μλ ΄ κ°μ§€λ΅ μ΅°κΈ° μΆ…λ£ (μ„Έλ€ {generation})")
    print(f"   {self.params.convergence_patience}μ„Έλ€ λ™μ• {self.params.convergence_threshold*100:.2f}% μ΄μƒ κ°μ„  μ—†μ")
    break
```

**μλ ΄ μ΅°κ±΄:**
- `convergence_patience`: μλ ΄ λ€κΈ° μ„Έλ€ μ
- `convergence_threshold`: κ°μ„  μ„κ³„κ°’ (%)

## π“ λΉ„μ© κµ¬μ„± μ”μ†λ³„ λ¶„μ„

### 1. Full μ»¨ν…μ΄λ„ λΉ„μ©

```python
# Full μ»¨ν…μ΄λ„λ‹Ή λΉ„μ©
full_cost_per_teu = CSHIP + CBAF + (CETA Γ— DELAY_i)
total_full_cost = Ξ£(full_cost_per_teu Γ— xF[i])
```

**λΉ„μ© μ”μ†:**
- **κΈ°λ³Έ μ΄μ†΅λΉ„**: `CSHIP` (κ³ μ •)
- **μ λ¥ν• μ¦λ£**: `CBAF` (κ³ μ •)
- **μ§€μ—° ν¨λ„ν‹°**: `CETA Γ— DELAY_i` (κ°€λ³€)

### 2. Empty μ»¨ν…μ΄λ„ λΉ„μ©

```python
# Empty μ»¨ν…μ΄λ„λ‹Ή λΉ„μ©
empty_cost_per_teu = CEMPTY_SHIP = CSHIP + CBAF
total_empty_cost = Ξ£(empty_cost_per_teu Γ— xE[i])
```

**νΉμ§•:**
- μ§€μ—° ν¨λ„ν‹° μ—†μ
- κΈ°λ³Έ μ΄μ†΅λΉ„ + μ λ¥ν• μ¦λ£λ§ μ μ©

### 3. μ§€μ—° ν¨λ„ν‹° κ³„μ‚°

```python
# μ§€μ—°μΌμ κ³„μ‚°
self.DELAY_i = {}
for i in self.I:
    if i in self.RETA_i and i in self.ETA_i:
        delay = (self.RETA_i[i] - self.ETA_i[i]).days
        self.DELAY_i[i] = max(0, delay)  # μμ λ°©μ§€
    else:
        self.DELAY_i[i] = 0
```

**μ§€μ—° ν¨λ„ν‹° νΉμ§•:**
- μ‹¤μ  μ§€μ—°μΌμλ§ κ³„μ‚°
- μμ μ§€μ—°μ€ 0μΌλ΅ μ²λ¦¬
- Full μ»¨ν…μ΄λ„μ—λ§ μ μ©

## π”„ μ„Έλ€λ³„ λΉ„μ© μµμ ν™” κ³Όμ •

### 1. μ΄κΈ° μ„Έλ€ (0-100)

**νΉμ§•:**
- λ†’μ€ λ‹¤μ–‘μ„±μΌλ΅ μΈν• λΉ„μ© νΈμ°¨ νΌ
- μ μ•½ μ΅°κ±΄ μ„λ°μΌλ΅ μΈν• λ†’μ€ ν¨λ„ν‹°
- κΈ°λ³Έ λΉ„μ© κµ¬μ΅° νƒμƒ‰

**μ¶λ ¥ μμ‹:**
```
μ„Έλ€    0: μ ν•©λ„= -1250000.00 | λ‹¤μ–‘μ„±= 85.23 | λ³€μ΄μ¨=0.100 | μ •μ²΄=  0 | 0.1s
  β”β”€ μ΄ λΉ„μ©: $1,250,000
  β”β”€ ν¨λ„ν‹°: 50000
  β””β”€ Full/Empty: 8500/1500 TEU
```

### 2. μ¤‘κ°„ μ„Έλ€ (100-500)

**νΉμ§•:**
- μ μ§„μ  λΉ„μ© κ°μ„ 
- μ μ•½ μ΅°κ±΄ μ„λ° κ°μ†
- ν¨λ„ν‹° λΉ„μ© μµμ†ν™”

**μ¶λ ¥ μμ‹:**
```
μ„Έλ€  200: μ ν•©λ„= -980000.00 | λ‹¤μ–‘μ„±= 65.45 | λ³€μ΄μ¨=0.075 | μ •μ²΄=  0 | 45.2s
  β”β”€ μ΄ λΉ„μ©: $980,000
  β”β”€ ν¨λ„ν‹°: 15000
  β””β”€ Full/Empty: 8200/1800 TEU
```

### 3. ν›„κΈ° μ„Έλ€ (500+)

**νΉμ§•:**
- λΉ„μ© μλ ΄ λ° μ•μ •ν™”
- λ‚®μ€ λ‹¤μ–‘μ„±μΌλ΅ μΈν• μ„Έλ°€ν• μ΅°μ •
- μµμ  λΉ„μ© κµ¬μ΅° λ°κ²¬

**μ¶λ ¥ μμ‹:**
```
μ„Έλ€  600: μ ν•©λ„= -920000.00 | λ‹¤μ–‘μ„±= 45.67 | λ³€μ΄μ¨=0.050 | μ •μ²΄= 15 | 120.5s
  β”β”€ μ΄ λΉ„μ©: $920,000
  β”β”€ ν¨λ„ν‹°: 5000
  β””β”€ Full/Empty: 8000/2000 TEU
```

## π“ λΉ„μ© μµμ ν™” μ„±κ³Ό μ§€ν‘

### 1. μ λ€μ  κ°μ„ 

```python
# κ°μ„ λ¥  κ³„μ‚°
if best_individual is not None:
    improvement_rate = (best['fitness'] - best_individual['fitness']) / abs(best_individual['fitness'])
    if improvement_rate > self.params.convergence_threshold:
        improvement = True
        stagnation_counter = 0
```

**κ°μ„  κΈ°μ¤€:**
- `convergence_threshold`: κ°μ„  μ„κ³„κ°’ (κΈ°λ³Έκ°’: 0.01 = 1%)
- 1% μ΄μƒ κ°μ„  μ‹ μ •μ²΄ μΉ΄μ΄ν„° λ¦¬μ…‹

### 2. μƒλ€μ  κ°μ„ 

```python
# μ„Έλ€λ³„ μ ν•©λ„ λ³€ν™”
best_fitness_history.append(best['fitness'])

# μµμΆ… κ²°κ³Ό
print(f"π† μµμΆ… μ ν•©λ„: {best_individual['fitness']:.2f}")
print(f"π“ μ΄ μ§„ν™” μ„Έλ€: {generation + 1}")
```

## π― λΉ„μ© μµμ ν™” ν•µμ‹¬ μΈμ‚¬μ΄νΈ

### 1. **λΉ„μ© κµ¬μ΅°μ λ³µμ΅μ„±**
- λ‹¨μν• μ„ ν• λΉ„μ©μ΄ μ•„λ‹ λ‹¤μΈµμ  λΉ„μ© κµ¬μ΅°
- μ§€μ—° ν¨λ„ν‹°κ°€ μ „μ²΄ λΉ„μ©μ— λ―ΈμΉλ” μν–¥μ΄ νΌ
- Full/Empty μ»¨ν…μ΄λ„ λΉ„μ¨μ΄ λΉ„μ© ν¨μ¨μ„± κ²°μ •

### 2. **μ μ•½ μ΅°κ±΄μ μ¤‘μ”μ„±**
- ν¨λ„ν‹° λΉ„μ©μ΄ μ‹¤μ  μ΄μ†΅ λΉ„μ©λ³΄λ‹¤ ν΄ μ μμ
- μ μ•½ μ΅°κ±΄ λ§μ΅±μ΄ λΉ„μ© μµμ ν™”μ ν•µμ‹¬
- μ©λ‰ μ μ•½κ³Ό μμ” μ¶©μ΅±μ κ· ν•μ΄ μ¤‘μ”

### 3. **μ„Έλ€λ³„ μµμ ν™” μ „λµ**
- μ΄κΈ°: μ μ•½ μ΅°κ±΄ μ„λ° μµμ†ν™”
- μ¤‘κΈ°: λΉ„μ© κµ¬μ΅° μµμ ν™”
- ν›„κΈ°: μ„Έλ°€ν• μ΅°μ •κ³Ό μλ ΄

## π”§ λΉ„μ© κ³„μ‚° μµμ ν™” ν

### 1. **νλΌλ―Έν„° νλ‹**
```python
# λΉ„μ© νλΌλ―Έν„° μ΅°μ •
self.params.CETA = 200  # μ§€μ—° ν¨λ„ν‹° μ¦κ°€
self.params.CBAF = 150  # μ λ¥ν• μ¦λ£ μ¦κ°€
```

### 2. **μ μ•½ μ΅°κ±΄ κ°€μ¤‘μΉ μ΅°μ •**
```python
# ν¨λ„ν‹° κ°€μ¤‘μΉ μ΅°μ •
demand_penalty += abs(total_full - demand) * 3000  # μμ” μ¶©μ΅± κ°€μ¤‘μΉ μ¦κ°€
capacity_penalty += (total_containers - capacity) * 2000  # μ©λ‰ μ μ•½ κ°€μ¤‘μΉ μ¦κ°€
```

### 3. **μλ ΄ μ΅°κ±΄ μµμ ν™”**
```python
# μλ ΄ νλΌλ―Έν„° μ΅°μ •
self.params.convergence_patience = 200  # λ” μ¤λ λ€κΈ°
self.params.convergence_threshold = 0.005  # λ” μ—„κ²©ν• κ°μ„  κΈ°μ¤€
```

## π“ κ²°λ΅ 

ν•΄μƒ μ΄μ†΅ GA μµμ ν™”μ—μ„ μ΄λΉ„μ© μ•κ³ λ¦¬μ¦μ€ **μ„Έλ€λ³„λ΅ μ§€μ†μ μΈ λ¨λ‹ν„°λ§κ³Ό μµμ ν™”**λ¥Ό ν†µν•΄ μ‘λ™ν•©λ‹λ‹¤. 

**ν•µμ‹¬ νΉμ§•:**
1. **μ‹¤μ‹κ°„ λΉ„μ© μ¶”μ **: λ§¤ μ„Έλ€λ§λ‹¤ λΉ„μ© κ³„μ‚° λ° κΈ°λ΅
2. **μ μ‘μ  μµμ ν™”**: λ‹¤μ–‘μ„±κ³Ό λ³€μ΄μ¨μ„ ν†µν• μ§€λ¥μ  νƒμƒ‰
3. **μ μ•½ μ΅°κ±΄ ν†µν•©**: λΉ„μ©κ³Ό μ μ•½ μ΅°κ±΄μ κ· ν•μ  μµμ ν™”
4. **μλ ΄ κ°μ§€**: ν¨μ¨μ μΈ μ΅°κΈ° μΆ…λ£λ΅ κ³„μ‚° μ‹κ°„ λ‹¨μ¶•

μ΄λ¬ν• μ²΄κ³„μ μΈ λΉ„μ© μµμ ν™” κ³Όμ •μ„ ν†µν•΄ ν•΄μƒ μ΄μ†΅μ λΉ„μ© ν¨μ¨μ„±μ„ κ·Ήλ€ν™”ν•  μ μμµλ‹λ‹¤.
