# -*- coding: utf-8 -*-
"""LP.ipynb의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17-ScquBUxpV9UxH2q1q51uQrrBSrCVHF
"""

from google.colab import drive
drive.mount("/content/drive")

"""# 데이터 불러오기"""

import pandas as pd
import numpy as np
from collections import defaultdict
from scipy.optimize import linprog

# 각 엑셀 파일을 데이터 프레임으로 불러오기
schedule_data = pd.read_excel('/content/drive/MyDrive/스마트해운물류 스터디/data/스해물_스케줄 data.xlsx')
delayed_schedule_data = pd.read_excel('/content/drive/MyDrive/스마트해운물류 스터디/data/스해물_딜레이 스케줄 data.xlsx')
vessel_data = pd.read_excel('/content/drive/MyDrive/스마트해운물류 스터디/data/스해물_선박 data.xlsx')
port_data = pd.read_excel('/content/drive/MyDrive/스마트해운물류 스터디/data/스해물_항구 위치 data.xlsx')

print("Schedule Data")
schedule_data.head()

print("\nDelayed Schedule Data")
delayed_schedule_data.head()

print("\nVessel Data")
vessel_data.head()

print("\nPort Data")
port_data.head()

# 고정값
# 컨테이너 용량(kg)
KG_PER_TEU = 30000

# 운송비(USD/TEU)
CSHIP = 1000

# 유류할증료(USD/TEU)
CBAF = 100

# ETA 패널티(USD/일)
CETA = 150

"""# Sets"""

# '항구명' 컬럼의 값들을 ports 변수에 저장
P = port_data['항구명'].unique().tolist()
print("Ports:")
print(P)

# 루트 번호
R = list(range(1, 102))
print("Routes:")
print(R)

# '선박명' 컬럼의 값들을 vessels 변수에 저장
V = vessel_data['선박명'].unique().tolist()
print("Vessels:")
print(V)

# '스케줄 번호' 컬럼의 값들을 sched 변수에 저장
I = schedule_data['스케줄 번호'].tolist()
print("Schedule Numbers:")
print(I)

# '스케줄 번호' 컬럼의 값들을 delayed_sched 변수에 저장
delayed_I = delayed_schedule_data['스케줄 번호'].tolist()
print("Delayed Schedule Numbers:")
print(I)

"""# Parameters"""

O_i = schedule_data.set_index('스케줄 번호')['출발항'].to_dict()
print("Origin ports for each schedule (O_i):")
print(O_i)

D_i = schedule_data.set_index('스케줄 번호')['도착항'].to_dict()
print("Destination ports for each schedule (D_i):")
print(D_i)

V_r = schedule_data.set_index('루트번호')['선박명'].to_dict()
print("Vessels assigned to each route (V_r):")
print(V_r)

Q_r = schedule_data.groupby('루트번호')['주문량(KG)'].sum().to_dict()
print("Total order quantity for each route (Q_r):")
print(Q_r)

ETD_i = schedule_data.set_index('스케줄 번호')['ETD'].to_dict()
print("Estimated Departure Times (ETD_i):")
print(ETD_i)

ETA_i = schedule_data.set_index('스케줄 번호')['ETA'].to_dict()
print("\nEstimated Arrival Times (ETA_i):")
print(ETA_i)

RETA_i = delayed_schedule_data.set_index('스케줄 번호')['딜레이 ETA'].to_dict()
print("Actual Arrival Times (RETA_i):")
print(RETA_i)

from google.colab import drive
drive.mount('/content/drive')

# Iterate through ETA_i and add to RETA_i if not present
for schedule_num in ETA_i:
    if schedule_num not in RETA_i:
        RETA_i[schedule_num] = ETA_i[schedule_num]

RETA_i = dict(sorted(RETA_i.items()))

print("Actual Arrival Times (RETA_i_sorted):")
print(RETA_i)

import math

D_ab = {}
for r in R:
  if r in Q_r: # Check if the route exists in Q_r
    D_ab[r] = math.ceil(Q_r[r] / KG_PER_TEU)

print("Order quantity in TEU for each route (D_ab):")
print(D_ab)

CAP_v = vessel_data.set_index('선박명')['용량(TEU)'].to_dict()
print("Vessel capacities (CAP_v):")
print(CAP_v)

CAP_v_r = {}
for r in V_r:
    vessel_name = V_r[r]
    if vessel_name in CAP_v:
        CAP_v_r[r] = CAP_v[vessel_name]
    else:
        # Handle cases where a vessel in V_r is not found in CAP_v if necessary
        CAP_v_r[r] = None # Or some other default value

print("Capacity of the vessel assigned to each route (CAP_v_r):")
print(CAP_v_r)

DELAY_i = {}
for i in I:
    if i in ETA_i and i in RETA_i:
        delay_days = (RETA_i[i] - ETA_i[i]).days
        DELAY_i[i] = max(0, delay_days)
    else:
        # Handle cases where a schedule number is not in both dictionaries if necessary
        DELAY_i[i] = 0 # Assuming no delay if data is missing

print("Delay in days for each schedule (DELAY_i):")
print(DELAY_i)

"""# Decision Variables"""

# Step 3: Define Decision Variables (Time-Phased Inventory Model)

# Based on user's clarification and assuming the PDF defines:
# xF_i: Number of full containers transported on schedule i (for i in I)
# xE_i: Number of empty containers transported on schedule i (for i in I)
# y_ip: Number of empty containers at port p after processing schedule i (for i in I, p in P)

# Define the number of schedules and ports
num_schedules = len(I) # Assuming I is defined (list of schedule numbers)
num_ports = len(P)   # Assuming P is defined (list of port names)

# Define the total number of variables:
# xF_i (num_schedules)
# xE_i (num_schedules)
# y_ip (num_schedules * num_ports)
num_variables = num_schedules + num_schedules + (num_schedules * num_ports)

# Create a list of decision variable names for clarity (optional)
# The order in this list should match the order in the flattened variable array for linprog
variable_names = [f'xF_{i}' for i in I] + \
                   [f'xE_{i}' for i in I] + \
                   [f'y_{i}_{p}' for i in I for p in P]


print("Number of schedules (num_schedules):", num_schedules)
print("Number of ports (num_ports):", num_ports)
print("Total number of decision variables (num_variables):", num_variables)
# print("Decision variable names (first few and last few):")
# print(variable_names[:5], "...", variable_names[-5:])

"""# LP Model"""

# Step 4: Formulate the Objective Function (Time-Phased Inventory Model)

# Analyze the PDF to get the coefficients for xF_i, xE_i, and y_ip
# Assuming the objective is to minimize total cost.
# Based on typical container shipping LPs and previous discussions:
# Cost for xF_i = CSHIP + CBAF + CETA * DELAY_i
# Cost for xE_i = Assuming a cost for transporting empty containers (let's use CEMPTY_SHIP)
# Cost for y_ip = Assuming an inventory holding cost at port p after schedule i (let's use CHOLD_p_i)
# Note: The holding cost might depend on the port p and/or the time step (schedule i).
# For simplicity, let's assume a constant holding cost per TEU per "schedule period" (CHOLD).

# Define placeholder costs if they are not explicitly defined in the PDF or previous cells
# (Replace these with actual values from the PDF if available)
CEMPTY_SHIP = CSHIP + CBAF # Assuming same transport cost for empty as full containers
CHOLD = 10 # Example holding cost per empty container per schedule period

# The coefficients for the objective function need to be a 1D array
# The order should match the order of decision variables: [xF_1, ..., xF_n, xE_1, ..., xE_n, y_1_p1, ..., y_n_pm]
# num_schedules and num_ports are assumed to be defined

c_obj = []

# Coefficients for xF_i
for i in I: # Assuming I is defined
    # Ensure DELAY_i is defined for this schedule
    if i in DELAY_i: # Assuming DELAY_i is defined
        c_obj.append(CSHIP + CBAF + CETA * DELAY_i[i]) # Assuming CSHIP, CBAF, CETA are defined
    else:
        # Assume no delay penalty if delay data is missing
        c_obj.append(CSHIP + CBAF)

# Coefficients for xE_i
for i in I: # Assuming I is defined
    # Assuming the cost for xE_i is CEMPTY_SHIP
    c_obj.append(CEMPTY_SHIP) # Using the placeholder cost

# Coefficients for y_ip
# Assuming a holding cost CHOLD for each y_ip
for i in I:
    for p in P: # Assuming P is defined
        c_obj.append(CHOLD) # Using the placeholder holding cost

# Convert to numpy array
c_obj = np.array(c_obj)

print("Objective function coefficients (c_obj):")
# print(c_obj) # Avoid printing very large arrays
print("c_obj shape:", c_obj.shape)
print("First 10 elements:", c_obj[:10]) # Print first few elements
print("Last 10 elements:", c_obj[-10:]) # Print last few elements


# Note: The exact objective function and costs should be verified from the PDF.
# Placeholder costs (CEMPTY_SHIP, CHOLD) are used if not specified in the PDF.

# Define I0_p (Initial empty containers at each port) - Using values from previous scenario
# Assuming P is defined
I0_p = {p: 0 for p in P}
I0_p['BUSAN'] = 50000
I0_p['LONG BEACH'] = 30000
I0_p['NEW YORK'] = 100000
I0_p['SAVANNAH'] = 20000
I0_p['HOUSTON'] = 10000
I0_p['MOBILE'] = 10000
# Note: 'SEATLE' had a typo in the previous definition, assuming it should be 'SEATTLE'
if 'SEATTLE' in P:
    I0_p['SEATTLE'] = 10000
else:
     # Handle case if 'SEATTLE' is not in P
     print("Warning: 'SEATTLE' not found in the list of ports (P). Skipping I0_p assignment for SEATTLE.")

print("Initial number of empty containers at each port (I0_p):")
print(I0_p)

# Step 5: Formulate Constraints (Time-Phased Inventory Model)

# Initialize constraint matrices/vectors as lists
A_ub = []
b_ub = []
A_eq = []
b_eq = []

# Assuming num_schedules, num_ports, num_variables are defined
# Assuming I, P, R, D_ab, CAP_v_r, O_i, D_i, I0_p, schedule_data are defined

# Assuming decision variables order: [xF_1..n, xE_1..n, y_1_p1..m, y_2_p1..m, ..., y_n_p1..m]
xF_indices = {i: I.index(i) for i in I}
xE_indices = {i: num_schedules + I.index(i) for i in I}
y_indices = {(i, p): 2 * num_schedules + I.index(i) * num_ports + P.index(p) for i in I for p in P}

# Constraint: Initial Inventory Balance (Linking I0_p to y_1p)
# y_1p = I0_p[p] + arrivals(schedule 1 at p) - departures(schedule 1 from p)
# Rearrange: y_1p - arrivals(schedule 1 at p) + departures(schedule 1 from p) = I0_p[p]
# Note: This assumes the first schedule I[0] is the first event affecting inventory.
# A more robust model would order events by time.
first_schedule = I[0]
for p in P:
    row = [0] * num_variables
    # Coefficient for y_1p
    row[y_indices[(first_schedule, p)]] = 1

    # Arrivals from the first schedule at port p
    if first_schedule in D_i and D_i[first_schedule] == p:
        row[xF_indices[first_schedule]] -= 1 # - (xF_1)
        row[xE_indices[first_schedule]] -= 1 # - (xE_1)

    # Departures from port p by the first schedule
    if first_schedule in O_i and O_i[first_schedule] == p:
        row[xF_indices[first_schedule]] += 1 # + (xF_1)
        row[xE_indices[first_schedule]] += 1 # + (xE_1)

    A_eq.append(row)
    b_eq.append(I0_p.get(p, 0)) # Right hand side is I0_p[p]


# Constraint: Time-Phased Inventory Balance (for schedules i > 1)
# y_ip = y_(i-1)p + arrivals(schedule i at p) - departures(schedule i from p)
# Rearrange: y_ip - y_(i-1)p - arrivals(schedule i at p) + departures(schedule i from p) = 0
for i_idx in range(1, num_schedules): # Iterate from the second schedule
    current_schedule = I[i_idx]
    previous_schedule = I[i_idx - 1]
    for p in P:
        row = [0] * num_variables
        # Coefficient for y_ip
        row[y_indices[(current_schedule, p)]] = 1

        # Coefficient for y_(i-1)p
        row[y_indices[(previous_schedule, p)]] = -1

        # Arrivals from the current schedule at port p
        if current_schedule in D_i and D_i[current_schedule] == p:
            row[xF_indices[current_schedule]] -= 1 # - (xF_i)
            row[xE_indices[current_schedule]] -= 1 # - (xE_i)

        # Departures from port p by the current schedule
        if current_schedule in O_i and O_i[current_schedule] == p:
            row[xF_indices[current_schedule]] += 1 # + (xF_i)
            row[xE_indices[current_schedule]] += 1 # + (xE_i)

        A_eq.append(row)
        b_eq.append(0) # Right hand side is 0


# Constraint: Demand Fulfillment for each route r (Assuming from PDF)
# Sum of xF_i for schedules i in route r must be >= D_ab[r]
# Convert to <= form: -Sum(xF_i for i in route r) <= -D_ab[r]
for r in R:
    if r in D_ab:
        row = [0] * num_variables
        schedules_in_route = schedule_data[schedule_data['루트번호'] == r]['스케줄 번호'].tolist()
        for i in I:
            if i in schedules_in_route:
                 row[xF_indices[i]] = -1
        A_ub.append(row)
        b_ub.append(-D_ab[r])


# Constraint: Vessel Capacity for each route r (Assuming from PDF)
# Sum of xF_i + Sum of xE_i for schedules i in route r must be <= CAP_v_r[r]
for r in R:
    if r in CAP_v_r and CAP_v_r[r] is not None:
        row = [0] * num_variables
        schedules_in_route = schedule_data[schedule_data['루트번호'] == r]['스케줄 번호'].tolist()
        for i in I:
            if i in schedules_in_route:
                row[xF_indices[i]] = 1
                row[xE_indices[i]] = 1
        A_ub.append(row)
        b_ub.append(CAP_v_r[r])

# New Constraint: Total Empty Container Transport on a Route is a Fraction of Vessel Capacity
# Sum of xE_i for schedules i in route r = theta * CAP_v_r[r] for each route r
theta = 0.001
for r in R:
    if r in CAP_v_r and CAP_v_r[r] is not None:
        row = [0] * num_variables
        schedules_in_route = schedule_data[schedule_data['루트번호'] == r]['스케줄 번호'].tolist()
        for i in I:
            if i in schedules_in_route:
                 # The index for xE_i is num_schedules + I.index(i)
                xE_index = num_schedules + I.index(i)
                row[xE_index] = 1 # Coefficient is 1 for equality constraint

        # Right-hand side is theta * CAP_v_r for route r
        rhs = theta * CAP_v_r[r]
        A_eq.append(row)
        b_eq.append(rhs)
    else:
        # Handle cases where capacity data is missing for a route if necessary
        print(f"Warning: Capacity data missing for route {r}. Skipping total empty container constraint.")


# Convert to numpy arrays
A_ub = np.array(A_ub)
b_ub = np.array(b_ub)
A_eq = np.array(A_eq)
b_eq = np.array(b_eq)


print("A_ub shape:", A_ub.shape)
print("b_ub shape:", b_ub.shape)
print("A_eq shape:", A_eq.shape)
print("b_eq shape:", b_eq.shape)

# Note: Additional constraints from the PDF should be added here following the same pattern.
# The exact constraints from the PDF need to be verified.

# Step 6: Set Variable Bounds

# Bounds for decision variables (xF_i >= 0, xE_i >= 0, y_ip >= 0)
# Assuming num_variables is defined from Step 3
bounds = [(0, None)] * num_variables

print("Bounds for decision variables:")
print(bounds[:5], "...", bounds[-5:]) # Print only first/last few bounds
print("Total number of bounds:", len(bounds))

# Step 7: Solve the LP Problem

from scipy.optimize import linprog

# Solve the linear programming problem
result = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds)

# Print the result of the solver
print(result)

# Step 8: Analyze and Output Results

# Check if the optimization was successful
if result.success:
    print("Optimization successful!")
    print(f"Optimal total cost: {result.fun}") # Print the optimal objective function value

    # Extract the optimal values of the decision variables
    optimal_x = result.x

    # Define the number of schedules and ports again for clarity
    num_schedules = len(I) # Assuming I is defined
    num_ports = len(P) # Assuming P is defined

    # Extract xF_i values and convert to integers
    xF_optimal = {}
    for idx, i in enumerate(I):
        xF_optimal[i] = int(round(optimal_x[idx])) # Round before converting

    # Extract xE_i values and convert to integers
    xE_optimal = {}
    for idx, i in enumerate(I):
        xE_optimal[i] = int(round(optimal_x[num_schedules + idx])) # Round before converting

    # Extract y_ip values and convert to integers, organize into a dictionary for DataFrame
    y_ip_optimal = {}
    y_ip_start_index = 2 * num_schedules
    for i_idx, i in enumerate(I):
        y_ip_optimal[i] = {}
        for p_idx, p in enumerate(P):
            variable_index = y_ip_start_index + i_idx * num_ports + p_idx
            y_ip_optimal[i][p] = int(round(optimal_x[variable_index])) # Round before converting

    print("\nOptimal values for xF_i (Full containers transported per schedule):")
    # Print dictionary directly
    print(xF_optimal)

    print("\nOptimal values for xE_i (Empty containers transported per schedule):")
    # Print dictionary directly
    print(xE_optimal)

    print("\nOptimal values for y_ip (Empty containers at port p after processing schedule i):")
    # Convert dictionary of dictionaries to DataFrame for better display
    y_ip_df = pd.DataFrame.from_dict(y_ip_optimal, orient='index')
    y_ip_df.index.name = 'Schedule Number'
    y_ip_df.columns.name = 'Port'
    display(y_ip_df)


else:
    print("Optimization failed.")
    print("Status:", result.status)
    print("Message:", result.message)



